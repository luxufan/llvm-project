; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt < %s -dse -S | FileCheck %s

define void @dont_sink_if_has_only_one_succ(ptr noalias %P) {
; CHECK-LABEL: @dont_sink_if_has_only_one_succ(
; CHECK-NEXT:    store i32 0, ptr [[P:%.*]], align 4
; CHECK-NEXT:    br label [[BB0:%.*]]
; CHECK:       bb0:
; CHECK-NEXT:    br i1 true, label [[BB1:%.*]], label [[BB2:%.*]]
; CHECK:       bb1:
; CHECK-NEXT:    br label [[BB3:%.*]]
; CHECK:       bb2:
; CHECK-NEXT:    store i32 1, ptr [[P]], align 4
; CHECK-NEXT:    br label [[BB3]]
; CHECK:       bb3:
; CHECK-NEXT:    ret void
;
  store i32 0, ptr %P
  br label %bb0
bb0:
  br i1 true, label %bb1, label %bb2

bb1:
  br label %bb3

bb2:
  store i32 1, ptr %P
  br label %bb3

bb3:
  ret void
}

define void @shouldnt_sink_since_theres_a_full_overlap(ptr %ptr, i1 %c) {
; CHECK-LABEL: @shouldnt_sink_since_theres_a_full_overlap(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[BPTRM1:%.*]] = getelementptr inbounds i8, ptr [[PTR:%.*]], i64 -1
; CHECK-NEXT:    [[BPTR3:%.*]] = getelementptr inbounds i8, ptr [[PTR]], i64 3
; CHECK-NEXT:    store i32 1234, ptr [[BPTRM1]], align 1
; CHECK-NEXT:    store i64 5678, ptr [[BPTR3]], align 1
; CHECK-NEXT:    br i1 [[C:%.*]], label [[BB1:%.*]], label [[BB2:%.*]]
; CHECK:       bb1:
; CHECK-NEXT:    br label [[BB3:%.*]]
; CHECK:       bb2:
; CHECK-NEXT:    store i64 1, ptr [[PTR]], align 4
; CHECK-NEXT:    br label [[BB3]]
; CHECK:       bb3:
; CHECK-NEXT:    ret void
;
entry:
  store i64 0, ptr %ptr
  %bptrm1 = getelementptr inbounds i8, ptr %ptr, i64 -1
  %bptr3 = getelementptr inbounds i8, ptr %ptr, i64 3
  store i32 1234, ptr %bptrm1, align 1
  store i64 5678, ptr %bptr3, align 1
  br i1 %c, label %bb1, label %bb2

bb1:
  br label %bb3

bb2:
  store i64 1, ptr %ptr
  br label %bb3

bb3:
  ret void
}

define void @dont_sink_if_succ_to_sink_will_reach_other_succs(ptr noalias %P) {
; CHECK-LABEL: @dont_sink_if_succ_to_sink_will_reach_other_succs(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    store i32 0, ptr [[P:%.*]], align 4
; CHECK-NEXT:    br i1 true, label [[BB1:%.*]], label [[BB2:%.*]]
; CHECK:       bb1:
; CHECK-NEXT:    store i32 1, ptr [[P]], align 4
; CHECK-NEXT:    br label [[BB2]]
; CHECK:       bb2:
; CHECK-NEXT:    ret void
;
entry:
  store i32 0, ptr %P
  br i1 true, label %bb1, label %bb2

bb1:
  store i32 1, ptr %P
  br label %bb2

bb2:
  ret void
}

define i32 @successor_of_each_other(i1 %c, ptr %p) {
; CHECK-LABEL: @successor_of_each_other(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[V:%.*]] = load i32, ptr [[P:%.*]], align 4
; CHECK-NEXT:    br i1 [[C:%.*]], label [[BB0:%.*]], label [[BB0_0:%.*]]
; CHECK:       bb0:
; CHECK-NEXT:    br i1 [[C]], label [[BB1:%.*]], label [[BB2:%.*]]
; CHECK:       bb0.0:
; CHECK-NEXT:    br label [[BB1]]
; CHECK:       bb1:
; CHECK-NEXT:    store i32 [[V]], ptr [[P]], align 4
; CHECK-NEXT:    br i1 [[C]], label [[BB3:%.*]], label [[BB0]]
; CHECK:       bb2:
; CHECK-NEXT:    store i32 0, ptr [[P]], align 4
; CHECK-NEXT:    br label [[BB3]]
; CHECK:       bb3:
; CHECK-NEXT:    ret i32 0
;
entry:
  %v = load i32, ptr %p, align 4
  br i1 %c, label %bb0, label %bb0.0

bb0:
  store i32 0, ptr %p
  br i1 %c, label %bb1, label %bb2

bb0.0:
  br label %bb1

bb1:
  store i32 %v, ptr %p, align 4
  br i1 %c, label %bb3, label %bb0

bb2:
  br label %bb3

bb3:
  ret i32 0
}
