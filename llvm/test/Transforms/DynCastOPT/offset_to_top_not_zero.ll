; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 4
; RUN: opt -passes=dyncastopt -S < %s | FileCheck %s
;
target datalayout = "e-m:e-i8:8:32-i16:16:32-i64:64-i128:128-n32:64-S128"
target triple = "aarch64-unknown-linux-gnu"

@_ZTVN10__cxxabiv117__class_type_infoE = external global [0 x ptr]
@_ZTS1A = internal constant [3 x i8] c"1A\00", align 1
@_ZTI1A = internal constant { ptr, ptr } { ptr getelementptr inbounds (ptr, ptr @_ZTVN10__cxxabiv117__class_type_infoE, i64 2), ptr @_ZTS1A }, align 8
@_ZTVN10__cxxabiv120__si_class_type_infoE = external global [0 x ptr]
@_ZTS2B1 = internal constant [4 x i8] c"2B1\00", align 1
@_ZTI2B1 = internal constant { ptr, ptr, ptr } { ptr getelementptr inbounds (ptr, ptr @_ZTVN10__cxxabiv120__si_class_type_infoE, i64 2), ptr @_ZTS2B1, ptr @_ZTI1A }, align 8
@_ZTS2B2 = internal constant [4 x i8] c"2B2\00", align 1
@_ZTI2B2 = internal constant { ptr, ptr, ptr } { ptr getelementptr inbounds (ptr, ptr @_ZTVN10__cxxabiv120__si_class_type_infoE, i64 2), ptr @_ZTS2B2, ptr @_ZTI1A }, align 8
@_ZTVN10__cxxabiv121__vmi_class_type_infoE = external global [0 x ptr]
@_ZTS1C = internal constant [3 x i8] c"1C\00", align 1
@_ZTI1C = internal constant { ptr, ptr, i32, i32, ptr, i64, ptr, i64 } { ptr getelementptr inbounds (ptr, ptr @_ZTVN10__cxxabiv121__vmi_class_type_infoE, i64 2), ptr @_ZTS1C, i32 1, i32 2, ptr @_ZTI2B1, i64 2, ptr @_ZTI2B2, i64 4098 }, align 8
@_ZTV2B1 = internal unnamed_addr constant { [4 x ptr] } { [4 x ptr] [ptr null, ptr @_ZTI2B1, ptr null, ptr null] }, align 8
@_ZTV1A = internal unnamed_addr constant { [4 x ptr] } { [4 x ptr] [ptr null, ptr @_ZTI1A, ptr null, ptr null] }, align 8
@_ZTV2B2 = internal unnamed_addr constant { [4 x ptr] } { [4 x ptr] [ptr null, ptr @_ZTI2B2, ptr null, ptr null] }, align 8
@_ZTS1D = internal constant [3 x i8] c"1D\00", align 1
@_ZTI1D = internal constant { ptr, ptr, ptr } { ptr getelementptr inbounds (ptr, ptr @_ZTVN10__cxxabiv120__si_class_type_infoE, i64 2), ptr @_ZTS1D, ptr @_ZTI1C }, align 8
@_ZTV1D = internal unnamed_addr constant { [4 x ptr], [4 x ptr] } { [4 x ptr] [ptr null, ptr @_ZTI1D, ptr null, ptr null], [4 x ptr] [ptr inttoptr (i64 -16 to ptr), ptr @_ZTI1D, ptr null, ptr null] }, align 8
declare ptr @__dynamic_cast(ptr, ptr, ptr, i64)

define internal ptr @_Z7dest_B1P1A(ptr %a) {
; CHECK-LABEL: define internal ptr @_Z7dest_B1P1A(
; CHECK-SAME: ptr [[A:%.*]]) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP0:%.*]] = icmp eq ptr [[A]], null
; CHECK-NEXT:    br i1 [[TMP0]], label [[DYNAMIC_CAST_NULL:%.*]], label [[LOAD_BLOCK:%.*]]
; CHECK:       load_block:
; CHECK-NEXT:    [[VPTR:%.*]] = load ptr, ptr [[A]], align 8
; CHECK-NEXT:    [[ADD_OFFSET_TO_TOP:%.*]] = getelementptr inbounds i8, ptr [[VPTR]], i64 -16
; CHECK-NEXT:    [[OFFSET_TO_TOP:%.*]] = load i64, ptr [[ADD_OFFSET_TO_TOP]], align 8
; CHECK-NEXT:    [[RUNTIME_OBJECT:%.*]] = getelementptr inbounds i8, ptr [[A]], i64 [[OFFSET_TO_TOP]]
; CHECK-NEXT:    [[RUNTIME_VPTR:%.*]] = load ptr, ptr [[RUNTIME_OBJECT]], align 8
; CHECK-NEXT:    br label [[CHECK_SUPER_0:%.*]]
; CHECK:       check_super.0:
; CHECK-NEXT:    [[TMP1:%.*]] = icmp eq ptr [[RUNTIME_VPTR]], getelementptr inbounds ({ [4 x ptr] }, ptr @_ZTV2B1, i32 0, i32 0, i64 2)
; CHECK-NEXT:    br i1 [[TMP1]], label [[HANDLE_OFFSET:%.*]], label [[CHECK_SUPER_1:%.*]]
; CHECK:       check_super.1:
; CHECK-NEXT:    [[TMP2:%.*]] = icmp eq ptr [[RUNTIME_VPTR]], getelementptr inbounds ({ [4 x ptr], [4 x ptr] }, ptr @_ZTV1D, i32 0, i32 0, i64 2)
; CHECK-NEXT:    br i1 [[TMP2]], label [[HANDLE_OFFSET]], label [[DYNAMIC_CAST_NOTNULL:%.*]]
; CHECK:       handle_offset:
; CHECK-NEXT:    [[TMP3:%.*]] = phi i64 [ 0, [[CHECK_SUPER_0]] ], [ 0, [[CHECK_SUPER_1]] ]
; CHECK-NEXT:    [[TMP4:%.*]] = getelementptr i8, ptr [[RUNTIME_OBJECT]], i64 [[TMP3]]
; CHECK-NEXT:    br label [[DYNAMIC_CAST_NOTNULL]]
; CHECK:       dynamic_cast.notnull:
; CHECK-NEXT:    [[TMP5:%.*]] = phi ptr [ null, [[CHECK_SUPER_1]] ], [ [[TMP4]], [[HANDLE_OFFSET]] ]
; CHECK-NEXT:    br label [[DYNAMIC_CAST_END:%.*]]
; CHECK:       dynamic_cast.null:
; CHECK-NEXT:    br label [[DYNAMIC_CAST_END]]
; CHECK:       dynamic_cast.end:
; CHECK-NEXT:    [[TMP6:%.*]] = phi ptr [ [[TMP5]], [[DYNAMIC_CAST_NOTNULL]] ], [ null, [[DYNAMIC_CAST_NULL]] ]
; CHECK-NEXT:    ret ptr [[TMP6]]
;
entry:
  %0 = icmp eq ptr %a, null
  br i1 %0, label %dynamic_cast.null, label %dynamic_cast.notnull

dynamic_cast.notnull:                             ; preds = %entry
  %1 = call ptr @__dynamic_cast(ptr nonnull %a, ptr nonnull @_ZTI1A, ptr nonnull @_ZTI2B1, i64 0)
  br label %dynamic_cast.end

dynamic_cast.null:                                ; preds = %entry
  br label %dynamic_cast.end

dynamic_cast.end:                                 ; preds = %dynamic_cast.null, %dynamic_cast.notnull
  %2 = phi ptr [ %1, %dynamic_cast.notnull ], [ null, %dynamic_cast.null ]
  ret ptr %2
}

define internal ptr @_Z7dest_B2P1A(ptr %a) {
; CHECK-LABEL: define internal ptr @_Z7dest_B2P1A(
; CHECK-SAME: ptr [[A:%.*]]) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP0:%.*]] = icmp eq ptr [[A]], null
; CHECK-NEXT:    br i1 [[TMP0]], label [[DYNAMIC_CAST_NULL:%.*]], label [[LOAD_BLOCK:%.*]]
; CHECK:       load_block:
; CHECK-NEXT:    [[VPTR:%.*]] = load ptr, ptr [[A]], align 8
; CHECK-NEXT:    [[ADD_OFFSET_TO_TOP:%.*]] = getelementptr inbounds i8, ptr [[VPTR]], i64 -16
; CHECK-NEXT:    [[OFFSET_TO_TOP:%.*]] = load i64, ptr [[ADD_OFFSET_TO_TOP]], align 8
; CHECK-NEXT:    [[RUNTIME_OBJECT:%.*]] = getelementptr inbounds i8, ptr [[A]], i64 [[OFFSET_TO_TOP]]
; CHECK-NEXT:    [[RUNTIME_VPTR:%.*]] = load ptr, ptr [[RUNTIME_OBJECT]], align 8
; CHECK-NEXT:    br label [[CHECK_SUPER_0:%.*]]
; CHECK:       check_super.0:
; CHECK-NEXT:    [[TMP1:%.*]] = icmp eq ptr [[RUNTIME_VPTR]], getelementptr inbounds ({ [4 x ptr] }, ptr @_ZTV2B2, i32 0, i32 0, i64 2)
; CHECK-NEXT:    br i1 [[TMP1]], label [[HANDLE_OFFSET:%.*]], label [[CHECK_SUPER_1:%.*]]
; CHECK:       check_super.1:
; CHECK-NEXT:    [[TMP2:%.*]] = icmp eq ptr [[RUNTIME_VPTR]], getelementptr inbounds ({ [4 x ptr], [4 x ptr] }, ptr @_ZTV1D, i32 0, i32 0, i64 2)
; CHECK-NEXT:    br i1 [[TMP2]], label [[HANDLE_OFFSET]], label [[DYNAMIC_CAST_NOTNULL:%.*]]
; CHECK:       handle_offset:
; CHECK-NEXT:    [[TMP3:%.*]] = phi i64 [ 0, [[CHECK_SUPER_0]] ], [ 16, [[CHECK_SUPER_1]] ]
; CHECK-NEXT:    [[TMP4:%.*]] = getelementptr i8, ptr [[RUNTIME_OBJECT]], i64 [[TMP3]]
; CHECK-NEXT:    br label [[DYNAMIC_CAST_NOTNULL]]
; CHECK:       dynamic_cast.notnull:
; CHECK-NEXT:    [[TMP5:%.*]] = phi ptr [ null, [[CHECK_SUPER_1]] ], [ [[TMP4]], [[HANDLE_OFFSET]] ]
; CHECK-NEXT:    br label [[DYNAMIC_CAST_END:%.*]]
; CHECK:       dynamic_cast.null:
; CHECK-NEXT:    br label [[DYNAMIC_CAST_END]]
; CHECK:       dynamic_cast.end:
; CHECK-NEXT:    [[TMP6:%.*]] = phi ptr [ [[TMP5]], [[DYNAMIC_CAST_NOTNULL]] ], [ null, [[DYNAMIC_CAST_NULL]] ]
; CHECK-NEXT:    ret ptr [[TMP6]]
;
entry:
  %0 = icmp eq ptr %a, null
  br i1 %0, label %dynamic_cast.null, label %dynamic_cast.notnull

dynamic_cast.notnull:                             ; preds = %entry
  %1 = call ptr @__dynamic_cast(ptr nonnull %a, ptr nonnull @_ZTI1A, ptr nonnull @_ZTI2B2, i64 0)
  br label %dynamic_cast.end

dynamic_cast.null:                                ; preds = %entry
  br label %dynamic_cast.end

dynamic_cast.end:                                 ; preds = %dynamic_cast.null, %dynamic_cast.notnull
  %2 = phi ptr [ %1, %dynamic_cast.notnull ], [ null, %dynamic_cast.null ]
  ret ptr %2
}

define internal ptr @_Z6dest_CP1A(ptr %a) {
; CHECK-LABEL: define internal ptr @_Z6dest_CP1A(
; CHECK-SAME: ptr [[A:%.*]]) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP0:%.*]] = icmp eq ptr [[A]], null
; CHECK-NEXT:    br i1 [[TMP0]], label [[DYNAMIC_CAST_END:%.*]], label [[LOAD_BLOCK:%.*]]
; CHECK:       load_block:
; CHECK-NEXT:    [[VPTR:%.*]] = load ptr, ptr [[A]], align 8
; CHECK-NEXT:    [[ADD_OFFSET_TO_TOP:%.*]] = getelementptr inbounds i8, ptr [[VPTR]], i64 -16
; CHECK-NEXT:    [[OFFSET_TO_TOP:%.*]] = load i64, ptr [[ADD_OFFSET_TO_TOP]], align 8
; CHECK-NEXT:    [[RUNTIME_OBJECT:%.*]] = getelementptr inbounds i8, ptr [[A]], i64 [[OFFSET_TO_TOP]]
; CHECK-NEXT:    [[RUNTIME_VPTR:%.*]] = load ptr, ptr [[RUNTIME_OBJECT]], align 8
; CHECK-NEXT:    br label [[CHECK_SUPER_0:%.*]]
; CHECK:       check_super.0:
; CHECK-NEXT:    [[TMP1:%.*]] = icmp eq ptr [[RUNTIME_VPTR]], getelementptr inbounds ({ [4 x ptr], [4 x ptr] }, ptr @_ZTV1D, i32 0, i32 0, i64 2)
; CHECK-NEXT:    br i1 [[TMP1]], label [[HANDLE_OFFSET:%.*]], label [[DYNAMIC_CAST_NOTNULL:%.*]]
; CHECK:       handle_offset:
; CHECK-NEXT:    [[TMP2:%.*]] = phi i64 [ 0, [[CHECK_SUPER_0]] ]
; CHECK-NEXT:    [[TMP3:%.*]] = getelementptr i8, ptr [[RUNTIME_OBJECT]], i64 [[TMP2]]
; CHECK-NEXT:    br label [[DYNAMIC_CAST_NOTNULL]]
; CHECK:       dynamic_cast.notnull:
; CHECK-NEXT:    [[TMP4:%.*]] = phi ptr [ null, [[CHECK_SUPER_0]] ], [ [[TMP3]], [[HANDLE_OFFSET]] ]
; CHECK-NEXT:    br label [[DYNAMIC_CAST_END]]
; CHECK:       dynamic_cast.end:
; CHECK-NEXT:    [[TMP5:%.*]] = phi ptr [ [[TMP4]], [[DYNAMIC_CAST_NOTNULL]] ], [ null, [[ENTRY:%.*]] ]
; CHECK-NEXT:    ret ptr [[TMP5]]
;
entry:
  %0 = icmp eq ptr %a, null
  br i1 %0, label %dynamic_cast.end, label %dynamic_cast.notnull

dynamic_cast.notnull:                             ; preds = %entry
  %1 = tail call ptr @__dynamic_cast(ptr nonnull %a, ptr nonnull @_ZTI1A, ptr nonnull @_ZTI1C, i64 -3) #7
  br label %dynamic_cast.end

dynamic_cast.end:                                 ; preds = %entry, %dynamic_cast.notnull
  %2 = phi ptr [ %1, %dynamic_cast.notnull ], [ null, %entry ]
  ret ptr %2
}

define internal noundef ptr @_Z6dest_DP1A(ptr noundef readonly %0) {
; CHECK-LABEL: define internal noundef ptr @_Z6dest_DP1A(
; CHECK-SAME: ptr noundef readonly [[TMP0:%.*]]) {
; CHECK-NEXT:    [[TMP2:%.*]] = icmp eq ptr [[TMP0]], null
; CHECK-NEXT:    br i1 [[TMP2]], label [[TMP8:%.*]], label [[LOAD_BLOCK:%.*]]
; CHECK:       load_block:
; CHECK-NEXT:    [[VPTR:%.*]] = load ptr, ptr [[TMP0]], align 8
; CHECK-NEXT:    [[ADD_OFFSET_TO_TOP:%.*]] = getelementptr inbounds i8, ptr [[VPTR]], i64 -16
; CHECK-NEXT:    [[OFFSET_TO_TOP:%.*]] = load i64, ptr [[ADD_OFFSET_TO_TOP]], align 8
; CHECK-NEXT:    [[RUNTIME_OBJECT:%.*]] = getelementptr inbounds i8, ptr [[TMP0]], i64 [[OFFSET_TO_TOP]]
; CHECK-NEXT:    [[RUNTIME_VPTR:%.*]] = load ptr, ptr [[RUNTIME_OBJECT]], align 8
; CHECK-NEXT:    br label [[CHECK_SUPER_0:%.*]]
; CHECK:       check_super.0:
; CHECK-NEXT:    [[TMP3:%.*]] = icmp eq ptr [[RUNTIME_VPTR]], getelementptr inbounds ({ [4 x ptr], [4 x ptr] }, ptr @_ZTV1D, i32 0, i32 0, i64 2)
; CHECK-NEXT:    br i1 [[TMP3]], label [[HANDLE_OFFSET:%.*]], label [[TMP6:%.*]]
; CHECK:       handle_offset:
; CHECK-NEXT:    [[TMP4:%.*]] = phi i64 [ 0, [[CHECK_SUPER_0]] ]
; CHECK-NEXT:    [[TMP5:%.*]] = getelementptr i8, ptr [[RUNTIME_OBJECT]], i64 [[TMP4]]
; CHECK-NEXT:    br label [[TMP6]]
; CHECK:       6:
; CHECK-NEXT:    [[TMP7:%.*]] = phi ptr [ null, [[CHECK_SUPER_0]] ], [ [[TMP5]], [[HANDLE_OFFSET]] ]
; CHECK-NEXT:    br label [[TMP8]]
; CHECK:       8:
; CHECK-NEXT:    [[TMP9:%.*]] = phi ptr [ [[TMP7]], [[TMP6]] ], [ null, [[TMP1:%.*]] ]
; CHECK-NEXT:    ret ptr [[TMP9]]
;
  %2 = icmp eq ptr %0, null
  br i1 %2, label %5, label %3

3:                                                ; preds = %1
  %4 = tail call ptr @__dynamic_cast(ptr nonnull %0, ptr nonnull @_ZTI1A, ptr nonnull @_ZTI1D, i64 -3)
  br label %5

5:                                                ; preds = %3, %1
  %6 = phi ptr [ %4, %3 ], [ null, %1 ]
  ret ptr %6
}
