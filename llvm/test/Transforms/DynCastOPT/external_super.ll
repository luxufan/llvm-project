; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 4
; RUN: opt -passes=dyncastopt -S < %s | FileCheck %s
;
target datalayout = "e-m:e-i8:8:32-i16:16:32-i64:64-i128:128-n32:64-S128"
target triple = "aarch64-unknown-linux-gnu"

@_ZTVN10__cxxabiv117__class_type_infoE = external global [0 x ptr]
@_ZTS1A = internal constant [3 x i8] c"1A\00", align 1
@_ZTI1A = internal constant { ptr, ptr } { ptr getelementptr inbounds (ptr, ptr @_ZTVN10__cxxabiv117__class_type_infoE, i64 2), ptr @_ZTS1A }, align 8
@_ZTVN10__cxxabiv120__si_class_type_infoE = external global [0 x ptr]
@_ZTS2B2 = internal constant [4 x i8] c"2B2\00", align 1
@_ZTI2B2 = internal constant { ptr, ptr, ptr } { ptr getelementptr inbounds (ptr, ptr @_ZTVN10__cxxabiv120__si_class_type_infoE, i64 2), ptr @_ZTS2B2, ptr @_ZTI1A }, align 8
@_ZTV2B2 = internal constant { [4 x ptr] } { [4 x ptr] [ptr null, ptr @_ZTI2B2, ptr null, ptr null] }, align 8, !type !0, !type !1, !vcall_visibility !4
@_ZTV1C = weak_odr constant { [4 x ptr] } { [4 x ptr] [ptr null, ptr @_ZTI1C, ptr null, ptr null] }, align 8, !type !0, !type !1, !type !2, !vcall_visibility !3
@_ZTS1C = weak_odr constant [3 x i8] c"1C\00", align 1
@_ZTI1C = weak_odr constant { ptr, ptr, ptr } { ptr getelementptr inbounds (ptr, ptr @_ZTVN10__cxxabiv120__si_class_type_infoE, i64 2), ptr @_ZTS1C, ptr @_ZTI2B2 }, align 8

declare ptr @__dynamic_cast(ptr, ptr, ptr, i64)

; TODO: Loading offset to top value is unnecessary since the class hierarchy is linear
define internal noundef ptr @_Z7dest_B2P1A(ptr noundef readonly %a) {
; CHECK-LABEL: define internal noundef ptr @_Z7dest_B2P1A(
; CHECK-SAME: ptr noundef readonly [[A:%.*]]) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP0:%.*]] = icmp eq ptr [[A]], null
; CHECK-NEXT:    br i1 [[TMP0]], label [[DYNAMIC_CAST_END:%.*]], label [[DYNAMIC_CAST_NOTNULL:%.*]]
; CHECK:       dynamic_cast.notnull:
; CHECK-NEXT:    [[TMP1:%.*]] = tail call ptr @__dynamic_cast(ptr nonnull [[A]], ptr nonnull @_ZTI1A, ptr nonnull @_ZTI2B2, i64 0)
; CHECK-NEXT:    br label [[DYNAMIC_CAST_END]]
; CHECK:       dynamic_cast.end:
; CHECK-NEXT:    [[TMP2:%.*]] = phi ptr [ [[TMP1]], [[DYNAMIC_CAST_NOTNULL]] ], [ null, [[ENTRY:%.*]] ]
; CHECK-NEXT:    ret ptr [[TMP2]]
;
entry:
  %0 = icmp eq ptr %a, null
  br i1 %0, label %dynamic_cast.end, label %dynamic_cast.notnull

dynamic_cast.notnull:                             ; preds = %entry
  %1 = tail call ptr @__dynamic_cast(ptr nonnull %a, ptr nonnull @_ZTI1A, ptr nonnull @_ZTI2B2, i64 0)
  br label %dynamic_cast.end

dynamic_cast.end:                                 ; preds = %dynamic_cast.notnull, %entry
  %2 = phi ptr [ %1, %dynamic_cast.notnull ], [ null, %entry ]
  ret ptr %2
}

!0 = !{i64 16, !"_ZTS1A"}
!1 = !{i64 16, !"_ZTS2B2"}
!2 = !{i64 16, !"_ZTS1C"}
!3 = !{i64 0}
!4 = !{i64 1}
