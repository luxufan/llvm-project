; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 4
; RUN: opt -passes=dyncastopt -S < %s | FileCheck %s
target datalayout = "e-m:e-i8:8:32-i16:16:32-i64:64-i128:128-n32:64-S128"
target triple = "aarch64-unknown-linux-gnu"


@_ZTVN10__cxxabiv117__class_type_infoE = external global [0 x ptr]
@_ZTS1A = internal constant [3 x i8] c"1A\00", align 1
@_ZTI1A = internal constant { ptr, ptr } { ptr getelementptr inbounds (ptr, ptr @_ZTVN10__cxxabiv117__class_type_infoE, i64 2), ptr @_ZTS1A }, align 8
@_ZTVN10__cxxabiv120__si_class_type_infoE = external global [0 x ptr]
@_ZTS2B1 = internal constant [4 x i8] c"2B1\00", align 1
@_ZTI2B1 = internal constant { ptr, ptr, ptr } { ptr getelementptr inbounds (ptr, ptr @_ZTVN10__cxxabiv120__si_class_type_infoE, i64 2), ptr @_ZTS2B1, ptr @_ZTI1A }, align 8
@_ZTS2B2 = internal constant [4 x i8] c"2B2\00", align 1
@_ZTI2B2 = internal constant { ptr, ptr, ptr } { ptr getelementptr inbounds (ptr, ptr @_ZTVN10__cxxabiv120__si_class_type_infoE, i64 2), ptr @_ZTS2B2, ptr @_ZTI1A }, align 8
@_ZTV1C = internal unnamed_addr constant { [4 x ptr], [4 x ptr] } { [4 x ptr] [ptr null, ptr @_ZTI1C, ptr null, ptr null], [4 x ptr] [ptr inttoptr (i64 -16 to ptr), ptr @_ZTI1C, ptr null, ptr null] }, align 8, !type !27, !type !28, !type !29, !type !30, !type !31, !vcall_visibility !33
@_ZTVN10__cxxabiv121__vmi_class_type_infoE = external global [0 x ptr]
@_ZTS1C = internal constant [3 x i8] c"1C\00", align 1
@_ZTI1C = internal constant { ptr, ptr, i32, i32, ptr, i64, ptr, i64 } { ptr getelementptr inbounds (ptr, ptr @_ZTVN10__cxxabiv121__vmi_class_type_infoE, i64 2), ptr @_ZTS1C, i32 1, i32 2, ptr @_ZTI2B1, i64 2, ptr @_ZTI2B2, i64 4098 }, align 8
@_ZTV2B1 = internal unnamed_addr constant { [4 x ptr] } { [4 x ptr] [ptr null, ptr @_ZTI2B1, ptr null, ptr null] }, align 8, !type !27, !type !30, !vcall_visibility !33
@_ZTV1A = internal unnamed_addr constant { [4 x ptr] } { [4 x ptr] [ptr null, ptr @_ZTI1A, ptr null, ptr null] }, align 8, !type !27, !vcall_visibility !33
@_ZTV2B2 = internal unnamed_addr constant { [4 x ptr] } { [4 x ptr] [ptr null, ptr @_ZTI2B2, ptr null, ptr null] }, align 8, !type !27, !type !32, !vcall_visibility !33
declare ptr @__dynamic_cast(ptr, ptr, ptr, i64)

define internal ptr @_Z6dest_CP1A(ptr %a) {
; CHECK-LABEL: define internal ptr @_Z6dest_CP1A(
; CHECK-SAME: ptr [[A:%.*]]) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP0:%.*]] = icmp eq ptr [[A]], null
; CHECK-NEXT:    br i1 [[TMP0]], label [[DYNAMIC_CAST_END:%.*]], label [[LOAD_BLOCK:%.*]]
; CHECK:       load_block:
; CHECK-NEXT:    [[P:%.*]] = load ptr, ptr [[A]], align 8
; CHECK-NEXT:    [[VPTR:%.*]] = load ptr, ptr [[P]], align 8
; CHECK-NEXT:    [[ADD_OFFSET_TO_TOP:%.*]] = getelementptr inbounds i8, ptr [[VPTR]], i64 -16
; CHECK-NEXT:    [[OFFSET_TO_TOP:%.*]] = load i64, ptr [[ADD_OFFSET_TO_TOP]], align 8
; CHECK-NEXT:    [[RUNTIME_OBJECT:%.*]] = getelementptr inbounds i8, ptr [[P]], i64 [[OFFSET_TO_TOP]]
; CHECK-NEXT:    [[RUNTIME_VPTR:%.*]] = load ptr, ptr [[RUNTIME_OBJECT]], align 8
; CHECK-NEXT:    br label [[CHECK_SUPER_0:%.*]]
; CHECK:       check_super.0:
; CHECK-NEXT:    [[TMP1:%.*]] = icmp eq ptr [[RUNTIME_VPTR]], getelementptr (i8, ptr @_ZTV1C, i64 16)
; CHECK-NEXT:    br i1 [[TMP1]], label [[HANDLE_OFFSET:%.*]], label [[DYNAMIC_CAST_NOTNULL:%.*]]
; CHECK:       handle_offset:
; CHECK-NEXT:    [[TMP2:%.*]] = phi ptr [ null, [[CHECK_SUPER_0]] ]
; CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[TMP2]] to i64
; CHECK-NEXT:    [[TMP4:%.*]] = sub i64 0, [[TMP3]]
; CHECK-NEXT:    [[TMP5:%.*]] = getelementptr i8, ptr [[RUNTIME_OBJECT]], i64 [[TMP4]]
; CHECK-NEXT:    br label [[DYNAMIC_CAST_NOTNULL]]
; CHECK:       dynamic_cast.notnull:
; CHECK-NEXT:    [[TMP6:%.*]] = phi ptr [ null, [[CHECK_SUPER_0]] ], [ [[TMP5]], [[HANDLE_OFFSET]] ]
; CHECK-NEXT:    br label [[DYNAMIC_CAST_END]]
; CHECK:       dynamic_cast.end:
; CHECK-NEXT:    [[TMP7:%.*]] = phi ptr [ [[TMP6]], [[DYNAMIC_CAST_NOTNULL]] ], [ null, [[ENTRY:%.*]] ]
; CHECK-NEXT:    ret ptr [[TMP7]]
;
entry:
  %0 = icmp eq ptr %a, null
  br i1 %0, label %dynamic_cast.end, label %dynamic_cast.notnull

dynamic_cast.notnull:                             ; preds = %entry
  %p = load ptr, ptr %a, align 8
  %1 = tail call ptr @__dynamic_cast(ptr %p, ptr nonnull @_ZTI1A, ptr nonnull @_ZTI1C, i64 -3) #7
  br label %dynamic_cast.end

dynamic_cast.end:                                 ; preds = %entry, %dynamic_cast.notnull
  %2 = phi ptr [ %1, %dynamic_cast.notnull ], [ null, %entry ]
  ret ptr %2
}

define internal ptr @_Z6dest_CP1A1(ptr %a) {
; CHECK-LABEL: define internal ptr @_Z6dest_CP1A1(
; CHECK-SAME: ptr [[A:%.*]]) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP0:%.*]] = icmp eq ptr [[A]], null
; CHECK-NEXT:    br i1 [[TMP0]], label [[DYNAMIC_CAST_END:%.*]], label [[LOAD_BLOCK:%.*]]
; CHECK:       load_block:
; CHECK-NEXT:    [[MERGE:%.*]] = phi i64 [ 0, [[ENTRY:%.*]] ]
; CHECK-NEXT:    [[VPTR:%.*]] = load ptr, ptr [[A]], align 8
; CHECK-NEXT:    [[ADD_OFFSET_TO_TOP:%.*]] = getelementptr inbounds i8, ptr [[VPTR]], i64 -16
; CHECK-NEXT:    [[OFFSET_TO_TOP:%.*]] = load i64, ptr [[ADD_OFFSET_TO_TOP]], align 8
; CHECK-NEXT:    [[RUNTIME_OBJECT:%.*]] = getelementptr inbounds i8, ptr [[A]], i64 [[OFFSET_TO_TOP]]
; CHECK-NEXT:    [[RUNTIME_VPTR:%.*]] = load ptr, ptr [[RUNTIME_OBJECT]], align 8
; CHECK-NEXT:    br label [[CHECK_SUPER_0:%.*]]
; CHECK:       check_super.0:
; CHECK-NEXT:    [[TMP1:%.*]] = icmp eq ptr [[RUNTIME_VPTR]], getelementptr (i8, ptr @_ZTV1C, i64 16)
; CHECK-NEXT:    br i1 [[TMP1]], label [[HANDLE_OFFSET:%.*]], label [[DYNAMIC_CAST_NOTNULL:%.*]]
; CHECK:       handle_offset:
; CHECK-NEXT:    [[TMP2:%.*]] = phi ptr [ null, [[CHECK_SUPER_0]] ]
; CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[TMP2]] to i64
; CHECK-NEXT:    [[TMP4:%.*]] = sub i64 0, [[TMP3]]
; CHECK-NEXT:    [[TMP5:%.*]] = getelementptr i8, ptr [[RUNTIME_OBJECT]], i64 [[TMP4]]
; CHECK-NEXT:    br label [[DYNAMIC_CAST_NOTNULL]]
; CHECK:       dynamic_cast.notnull:
; CHECK-NEXT:    [[TMP6:%.*]] = phi ptr [ null, [[CHECK_SUPER_0]] ], [ [[TMP5]], [[HANDLE_OFFSET]] ]
; CHECK-NEXT:    br label [[DYNAMIC_CAST_END]]
; CHECK:       dynamic_cast.end:
; CHECK-NEXT:    [[TMP7:%.*]] = phi ptr [ [[TMP6]], [[DYNAMIC_CAST_NOTNULL]] ], [ null, [[ENTRY]] ]
; CHECK-NEXT:    ret ptr [[TMP7]]
;
entry:
  %0 = icmp eq ptr %a, null
  br i1 %0, label %dynamic_cast.end, label %dynamic_cast.notnull

dynamic_cast.notnull:                             ; preds = %entry
  %merge = phi i64 [0, %entry]
  %1 = tail call ptr @__dynamic_cast(ptr %a, ptr nonnull @_ZTI1A, ptr nonnull @_ZTI1C, i64 -3) #7
  br label %dynamic_cast.end

dynamic_cast.end:                                 ; preds = %entry, %dynamic_cast.notnull
  %2 = phi ptr [ %1, %dynamic_cast.notnull ], [ null, %entry ]
  ret ptr %2
}

declare void @llvm.dbg.value(metadata, metadata, metadata)
define internal ptr @with_debug(ptr %a) {
; CHECK-LABEL: define internal ptr @with_debug(
; CHECK-SAME: ptr [[A:%.*]]) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP0:%.*]] = icmp eq ptr [[A]], null
; CHECK-NEXT:    br i1 [[TMP0]], label [[DYNAMIC_CAST_END:%.*]], label [[LOAD_BLOCK:%.*]]
; CHECK:       load_block:
; CHECK-NEXT:    call void @llvm.dbg.value(metadata i32 0, metadata [[META13:![0-9]+]], metadata !DIExpression()), !dbg [[DBG19:![0-9]+]]
; CHECK-NEXT:    [[VPTR:%.*]] = load ptr, ptr [[A]], align 8
; CHECK-NEXT:    [[ADD_OFFSET_TO_TOP:%.*]] = getelementptr inbounds i8, ptr [[VPTR]], i64 -16
; CHECK-NEXT:    [[OFFSET_TO_TOP:%.*]] = load i64, ptr [[ADD_OFFSET_TO_TOP]], align 8
; CHECK-NEXT:    [[RUNTIME_OBJECT:%.*]] = getelementptr inbounds i8, ptr [[A]], i64 [[OFFSET_TO_TOP]]
; CHECK-NEXT:    [[RUNTIME_VPTR:%.*]] = load ptr, ptr [[RUNTIME_OBJECT]], align 8
; CHECK-NEXT:    br label [[CHECK_SUPER_0:%.*]]
; CHECK:       check_super.0:
; CHECK-NEXT:    [[TMP1:%.*]] = icmp eq ptr [[RUNTIME_VPTR]], getelementptr (i8, ptr @_ZTV1C, i64 16)
; CHECK-NEXT:    br i1 [[TMP1]], label [[HANDLE_OFFSET:%.*]], label [[DYNAMIC_CAST_NOTNULL:%.*]]
; CHECK:       handle_offset:
; CHECK-NEXT:    [[TMP2:%.*]] = phi ptr [ null, [[CHECK_SUPER_0]] ]
; CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[TMP2]] to i64
; CHECK-NEXT:    [[TMP4:%.*]] = sub i64 0, [[TMP3]]
; CHECK-NEXT:    [[TMP5:%.*]] = getelementptr i8, ptr [[RUNTIME_OBJECT]], i64 [[TMP4]]
; CHECK-NEXT:    br label [[DYNAMIC_CAST_NOTNULL]]
; CHECK:       dynamic_cast.notnull:
; CHECK-NEXT:    [[TMP6:%.*]] = phi ptr [ null, [[CHECK_SUPER_0]] ], [ [[TMP5]], [[HANDLE_OFFSET]] ]
; CHECK-NEXT:    br label [[DYNAMIC_CAST_END]]
; CHECK:       dynamic_cast.end:
; CHECK-NEXT:    [[TMP7:%.*]] = phi ptr [ [[TMP6]], [[DYNAMIC_CAST_NOTNULL]] ], [ null, [[ENTRY:%.*]] ]
; CHECK-NEXT:    ret ptr [[TMP7]]
;
entry:
  %0 = icmp eq ptr %a, null
  br i1 %0, label %dynamic_cast.end, label %dynamic_cast.notnull

dynamic_cast.notnull:                             ; preds = %entry
  call void @llvm.dbg.value(metadata i32 0, metadata !12, metadata !DIExpression()), !dbg !13
  %1 = tail call ptr @__dynamic_cast(ptr %a, ptr nonnull @_ZTI1A, ptr nonnull @_ZTI1C, i64 -3) #7
  br label %dynamic_cast.end

dynamic_cast.end:                                 ; preds = %entry, %dynamic_cast.notnull
  %2 = phi ptr [ %1, %dynamic_cast.notnull ], [ null, %entry ]
  ret ptr %2
}

define dso_local noundef i32 @main() {
; CHECK-LABEL: define dso_local noundef i32 @main() {
; CHECK-NEXT:  load_block:
; CHECK-NEXT:    [[CALL:%.*]] = tail call noalias noundef nonnull dereferenceable(24) ptr @_Znwm(i64 noundef 24)
; CHECK-NEXT:    tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 16 dereferenceable(24) [[CALL]], i8 0, i64 24, i1 false)
; CHECK-NEXT:    store ptr getelementptr inbounds ({ [4 x ptr] }, ptr @_ZTV1C, i64 0, inrange i32 0, i64 2), ptr [[CALL]], align 8
; CHECK-NEXT:    [[VPTR:%.*]] = load ptr, ptr [[CALL]], align 8
; CHECK-NEXT:    [[ADD_OFFSET_TO_TOP:%.*]] = getelementptr inbounds i8, ptr [[VPTR]], i64 -16
; CHECK-NEXT:    [[OFFSET_TO_TOP:%.*]] = load i64, ptr [[ADD_OFFSET_TO_TOP]], align 8
; CHECK-NEXT:    [[RUNTIME_OBJECT:%.*]] = getelementptr inbounds i8, ptr [[CALL]], i64 [[OFFSET_TO_TOP]]
; CHECK-NEXT:    [[RUNTIME_VPTR:%.*]] = load ptr, ptr [[RUNTIME_OBJECT]], align 8
; CHECK-NEXT:    br label [[CHECK_SUPER_0:%.*]]
; CHECK:       check_super.0:
; CHECK-NEXT:    [[TMP0:%.*]] = icmp eq ptr [[RUNTIME_VPTR]], getelementptr (i8, ptr @_ZTV1C, i64 16)
; CHECK-NEXT:    br i1 [[TMP0]], label [[HANDLE_OFFSET:%.*]], label [[CHECK_SUPER_1:%.*]]
; CHECK:       check_super.1:
; CHECK-NEXT:    [[TMP1:%.*]] = icmp eq ptr [[RUNTIME_VPTR]], getelementptr (i8, ptr @_ZTV2B1, i64 16)
; CHECK-NEXT:    br i1 [[TMP1]], label [[HANDLE_OFFSET]], label [[ENTRY:%.*]]
; CHECK:       handle_offset:
; CHECK-NEXT:    [[TMP2:%.*]] = phi ptr [ null, [[CHECK_SUPER_0]] ], [ null, [[CHECK_SUPER_1]] ]
; CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[TMP2]] to i64
; CHECK-NEXT:    [[TMP4:%.*]] = sub i64 0, [[TMP3]]
; CHECK-NEXT:    [[TMP5:%.*]] = getelementptr i8, ptr [[RUNTIME_OBJECT]], i64 [[TMP4]]
; CHECK-NEXT:    br label [[ENTRY]]
; CHECK:       entry:
; CHECK-NEXT:    [[TMP6:%.*]] = phi ptr [ null, [[CHECK_SUPER_1]] ], [ [[TMP5]], [[HANDLE_OFFSET]] ]
; CHECK-NEXT:    ret i32 0
;
entry:
  %call = tail call noalias noundef nonnull dereferenceable(24) ptr @_Znwm(i64 noundef 24)
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 16 dereferenceable(24) %call, i8 0, i64 24, i1 false)
  store ptr getelementptr inbounds ({ [4 x ptr] }, ptr @_ZTV1C, i64 0, inrange i32 0, i64 2), ptr %call, align 8
  %0 = tail call ptr @__dynamic_cast(ptr nonnull %call, ptr nonnull @_ZTI1A, ptr nonnull @_ZTI2B1, i64 0)
  ret i32 0
}

declare noundef nonnull ptr @_Znwm(i64 noundef)
declare void @llvm.memset.p0.i64(ptr nocapture writeonly, i8, i64, i1 immarg)

!27 = !{i64 16, !"_ZTS1A"}
!28 = !{i64 48, !"_ZTS1A"}
!29 = !{i64 16, !"_ZTS1C"}
!30 = !{i64 16, !"_ZTS2B1"}
!31 = !{i64 48, !"_ZTS2B2"}
!32 = !{i64 16, !"_ZTS2B2"}
!33 = !{i64 1}

!llvm.dbg.cu = !{!0}
!llvm.module.flags = !{!3, !4, !5}
!llvm.ident = !{!6}

!0 = distinct !DICompileUnit(language: DW_LANG_C99, file: !1, isOptimized: false, runtimeVersion: 0, emissionKind: FullDebug, enums: !2, splitDebugInlining: false, nameTableKind: None)
!1 = !DIFile(filename: "test.c", directory: "/tmp/out.c")
!2 = !{}
!3 = !{i32 7, !"Dwarf Version", i32 4}
!4 = !{i32 2, !"Debug Info Version", i32 3}
!5 = !{i32 1, !"wchar_size", i32 4}
!6 = !{!""}
!7 = distinct !DISubprogram(name: "foo", scope: !1, file: !1, line: 3, type: !8, scopeLine: 3, flags: DIFlagPrototyped, spFlags: DISPFlagDefinition, unit: !0, retainedNodes: !2)
!8 = !DISubroutineType(types: !9)
!9 = !{!10, !11, !11}
!10 = !DIBasicType(name: "int", size: 32, encoding: DW_ATE_signed)
!11 = !DIBasicType(name: "long int", size: 64, encoding: DW_ATE_signed)
!12 = !DILocalVariable(name: "bar", arg: 1, scope: !7, file: !1, line: 3, type: !11)
!13 = !DILocation(line: 0, scope: !7)
!14 = !DILocalVariable(name: "baz", arg: 2, scope: !7, file: !1, line: 3, type: !11)
!19 = distinct !DILexicalBlock(scope: !7, file: !1, line: 8, column: 7)
!26 = !DILocation(line: 13, column: 3, scope: !7)
;.
; CHECK: [[META6:![0-9]+]] = distinct !DICompileUnit(language: DW_LANG_C99, file: [[META7:![0-9]+]], isOptimized: false, runtimeVersion: 0, emissionKind: FullDebug, enums: [[META8:![0-9]+]], splitDebugInlining: false, nameTableKind: None)
; CHECK: [[META7]] = !DIFile(filename: "test.c", directory: {{.*}})
; CHECK: [[META8]] = !{}
; CHECK: [[META13]] = !DILocalVariable(name: "bar", arg: 1, scope: [[META14:![0-9]+]], file: [[META7]], line: 3, type: [[META18:![0-9]+]])
; CHECK: [[META14]] = distinct !DISubprogram(name: "foo", scope: [[META7]], file: [[META7]], line: 3, type: [[META15:![0-9]+]], scopeLine: 3, flags: DIFlagPrototyped, spFlags: DISPFlagDefinition, unit: [[META6]], retainedNodes: [[META8]])
; CHECK: [[META15]] = !DISubroutineType(types: [[META16:![0-9]+]])
; CHECK: [[META16]] = !{[[META17:![0-9]+]], [[META18]], [[META18]]}
; CHECK: [[META17]] = !DIBasicType(name: "int", size: 32, encoding: DW_ATE_signed)
; CHECK: [[META18]] = !DIBasicType(name: "long int", size: 64, encoding: DW_ATE_signed)
; CHECK: [[DBG19]] = !DILocation(line: 0, scope: [[META14]])
;.
