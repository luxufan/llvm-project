; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 2
; RUN: opt -passes=gvn -S %s | FileCheck %s

define void @test(ptr %array, i32 %v0, i32 %v1, i32 %v2) {
; CHECK-LABEL: define void @test
; CHECK-SAME: (ptr [[ARRAY:%.*]], i32 [[V0:%.*]], i32 [[V1:%.*]], i32 [[V2:%.*]]) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[ARRAY_2:%.*]] = getelementptr inbounds i8, ptr [[ARRAY]], i64 32
; CHECK-NEXT:    [[ARRAY_3:%.*]] = getelementptr inbounds i8, ptr [[ARRAY]], i64 40
; CHECK-NEXT:    br label [[HEADER:%.*]]
; CHECK:       header:
; CHECK-NEXT:    [[ARRAY_2_PHI_1:%.*]] = phi ptr [ [[ARRAY_2]], [[ENTRY:%.*]] ], [ [[ARRAY_2_PHI_2:%.*]], [[LATCH:%.*]] ]
; CHECK-NEXT:    [[ARRAY_3_PHI_1:%.*]] = phi ptr [ [[ARRAY_3]], [[ENTRY]] ], [ [[ARRAY_3_PHI_2:%.*]], [[LATCH]] ]
; CHECK-NEXT:    [[LOCAL_I5:%.*]] = phi i64 [ 4, [[ENTRY]] ], [ [[LOCAL_I5_NEXT:%.*]], [[LATCH]] ]
; CHECK-NEXT:    [[V18:%.*]] = icmp eq i32 [[V1]], 0
; CHECK-NEXT:    br i1 [[V18]], label [[MERGE:%.*]], label [[THEN_BLOCK:%.*]]
; CHECK:       then_block:
; CHECK-NEXT:    [[ARRAY_RELOC_1:%.*]] = call ptr @realloc(ptr [[ARRAY]])
; CHECK-NEXT:    [[ARRAY_2_REMAT:%.*]] = getelementptr inbounds i8, ptr [[ARRAY_RELOC_1]], i64 32
; CHECK-NEXT:    [[ARRAY_3_REMAT:%.*]] = getelementptr inbounds i8, ptr [[ARRAY_RELOC_1]], i64 40
; CHECK-NEXT:    br label [[MERGE]]
; CHECK:       merge:
; CHECK-NEXT:    [[ARRAY_3_PHI_2]] = phi ptr [ [[ARRAY_3_PHI_1]], [[HEADER]] ], [ [[ARRAY_3_REMAT]], [[THEN_BLOCK]] ]
; CHECK-NEXT:    [[ARRAY_2_PHI_2]] = phi ptr [ [[ARRAY_2_PHI_1]], [[HEADER]] ], [ [[ARRAY_2_REMAT]], [[THEN_BLOCK]] ]
; CHECK-NEXT:    [[V22:%.*]] = icmp eq i32 [[V0]], 0
; CHECK-NEXT:    br i1 [[V22]], label [[ITER_PEEL:%.*]], label [[SIDE_EXIT:%.*]]
; CHECK:       iter.peel:
; CHECK-NEXT:    [[VAL_ARRAY_2_3_1:%.*]] = load <2 x i64>, ptr [[ARRAY_2_PHI_2]], align 8
; CHECK-NEXT:    [[V24:%.*]] = insertelement <2 x i64> poison, i64 [[LOCAL_I5]], i64 0
; CHECK-NEXT:    [[V25:%.*]] = shufflevector <2 x i64> [[V24]], <2 x i64> poison, <2 x i32> zeroinitializer
; CHECK-NEXT:    [[VAL_ARRAY_2_3_2:%.*]] = add <2 x i64> [[VAL_ARRAY_2_3_1]], [[V25]]
; CHECK-NEXT:    store <2 x i64> [[VAL_ARRAY_2_3_2]], ptr [[ARRAY_2_PHI_2]], align 8
; CHECK-NEXT:    [[VAL_ARRAY_3_1:%.*]] = load atomic i64, ptr [[ARRAY_3_PHI_2]] unordered, align 8
; CHECK-NEXT:    [[VAL_ARRAY_3_2:%.*]] = mul i64 [[VAL_ARRAY_3_1]], -1802
; CHECK-NEXT:    store atomic i64 [[VAL_ARRAY_3_2]], ptr [[ARRAY_3_PHI_2]] unordered, align 8
; CHECK-NEXT:    [[V30:%.*]] = icmp eq i32 [[V2]], 0
; CHECK-NEXT:    br i1 [[V30]], label [[LATCH]], label [[SIDE_EXIT]]
; CHECK:       latch:
; CHECK-NEXT:    [[VAL_ARRAY_2_3_3:%.*]] = load <2 x i64>, ptr [[ARRAY_2_PHI_2]], align 8
; CHECK-NEXT:    [[VAL_ARRAY_2_3_4:%.*]] = add <2 x i64> [[VAL_ARRAY_2_3_3]], [[V25]]
; CHECK-NEXT:    store <2 x i64> [[VAL_ARRAY_2_3_4]], ptr [[ARRAY_2_PHI_2]], align 8
; CHECK-NEXT:    [[LOCAL_I5_NEXT]] = add nuw nsw i64 [[LOCAL_I5]], 2
; CHECK-NEXT:    [[TEST_I5:%.*]] = icmp ugt i64 [[LOCAL_I5]], 250
; CHECK-NEXT:    br i1 [[TEST_I5]], label [[RETURN:%.*]], label [[HEADER]]
; CHECK:       return:
; CHECK-NEXT:    ret void
; CHECK:       side_exit:
; CHECK-NEXT:    [[VAL_ARRAY_2_1:%.*]] = load atomic i64, ptr [[ARRAY_2_PHI_2]] unordered, align 8
; CHECK-NEXT:    [[VAL_ARRAY_2_2:%.*]] = add i64 [[VAL_ARRAY_2_1]], [[LOCAL_I5]]
; CHECK-NEXT:    store atomic i64 [[VAL_ARRAY_2_2]], ptr [[ARRAY_2_PHI_2]] unordered, align 8
; CHECK-NEXT:    ret void
;
entry:
  %array.2 = getelementptr inbounds i8, ptr %array, i64 32
  %array.3 = getelementptr inbounds i8, ptr %array, i64 40
  br label %header

header:
  %array.2.phi.1 = phi ptr [ %array.2, %entry ], [ %array.2.phi.2, %latch ]
  %array.3.phi.1 = phi ptr [ %array.3, %entry ], [ %array.3.phi.2, %latch ]
  %local_i5 = phi i64 [ 4, %entry ], [ %local_i5.next, %latch ]
  %v18 = icmp eq i32 %v1, 0
  br i1 %v18, label %merge, label %then_block

then_block:
  %array.reloc.1 = call ptr @realloc(ptr %array)
  %array.2.remat = getelementptr inbounds i8, ptr %array.reloc.1, i64 32
  %array.3.remat = getelementptr inbounds i8, ptr %array.reloc.1, i64 40
  br label %merge

merge:
  %array.3.phi.2 = phi ptr [ %array.3.phi.1, %header ], [ %array.3.remat, %then_block ]
  %array.2.phi.2 = phi ptr [ %array.2.phi.1, %header ], [ %array.2.remat, %then_block ]
  %v22 = icmp eq i32 %v0, 0
  br i1 %v22, label %iter.peel, label %side_exit

iter.peel:
  %val.array.2_3.1 = load <2 x i64>, ptr %array.2.phi.2, align 8
  %v24 = insertelement <2 x i64> poison, i64 %local_i5, i64 0
  %v25 = shufflevector <2 x i64> %v24, <2 x i64> poison, <2 x i32> zeroinitializer
  %val.array.2_3.2 = add <2 x i64> %val.array.2_3.1, %v25
  store <2 x i64> %val.array.2_3.2, ptr %array.2.phi.2, align 8
  %val.array.3.1 = load atomic i64, ptr %array.3.phi.2 unordered, align 8
  %val.array.3.2 = mul i64 %val.array.3.1, -1802
  store atomic i64 %val.array.3.2, ptr %array.3.phi.2 unordered, align 8
  %v30 = icmp eq i32 %v2, 0
  br i1 %v30, label %latch, label %side_exit

latch:
  %val.array.2_3.3 = load <2 x i64>, ptr %array.2.phi.2, align 8
  %val.array.2_3.4 = add <2 x i64> %val.array.2_3.3, %v25
  store <2 x i64> %val.array.2_3.4, ptr %array.2.phi.2, align 8
  %local_i5.next= add nuw nsw i64 %local_i5, 2
  %test_i5 = icmp ugt i64 %local_i5, 250
  br i1 %test_i5, label %return, label %header

return:
  ret void

side_exit:
  %array.2.phi.2.lcssa = phi ptr [ %array.2.phi.2, %iter.peel ], [ %array.2.phi.2, %merge ]
  %val.array.2.1 = load atomic i64, ptr %array.2.phi.2.lcssa unordered, align 8
  %val.array.2.2 = add i64 %val.array.2.1, %local_i5
  store atomic i64 %val.array.2.2, ptr %array.2.phi.2.lcssa unordered, align 8
  ret void
}

declare ptr @realloc(ptr)
